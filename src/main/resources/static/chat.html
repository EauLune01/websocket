<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8"/>
    <title>실시간 채팅</title>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>

    <!-- 반드시 이 순서 -->
    <script src="https://cdn.jsdelivr.net/npm/sockjs-client@1/dist/sockjs.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/stomp.js/2.3.3/stomp.min.js"></script>

    <style>
        :root{
          --bg:#0e1117; --fg:#e6edf3; --muted:#9aa4b2; --card:#161b22; --line:#2b313c;
          --mine:#3b82f6; --other:#22c55e; --warn:#f59e0b; --info:#60a5fa; --ok:#22c55e;
        }
        *{box-sizing:border-box}
        body{margin:0;background:var(--bg);color:var(--fg);font-family:ui-sans-serif,system-ui,Apple SD Gothic Neo,Noto Sans KR,Segoe UI,Roboto,sans-serif}
        .wrap{max-width:920px;margin:24px auto;padding:0 16px}
        .top{display:flex;gap:10px;align-items:center;margin-bottom:14px}
        .pill{margin-left:auto;padding:6px 10px;border:1px solid var(--line);border-radius:999px;color:var(--muted);font-size:12px}
        .grid{display:grid;grid-template-columns:260px 1fr;gap:16px}
        @media (max-width:860px){.grid{grid-template-columns:1fr}}
        .card{background:var(--card);border:1px solid var(--line);border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,.25)}
        .side{padding:14px}
        .legend{font-size:12px;color:var(--muted);margin-bottom:8px}
        .hr{height:1px;background:var(--line);margin:10px 0;border-radius:1px}
        .main{padding:14px}
        .chat{height:56vh;min-height:360px;max-height:70vh;overflow:auto;padding:6px;display:flex;flex-direction:column;gap:12px}
        .msg{max-width:76%;padding:10px 12px;border-radius:16px;border:1px solid var(--line)}
        .msg.mine{align-self:flex-end;background:rgba(59,130,246,.10);border-color:rgba(59,130,246,.35)}
        .msg.other{align-self:flex-start;background:rgba(34,197,94,.10);border-color:rgba(34,197,94,.35)}
        .meta{display:flex;gap:8px;align-items:center;margin-bottom:4px;font-size:12px;color:var(--muted)}
        .meta .name{font-weight:700;color:#cbd5e1}
        .content{white-space:pre-wrap;line-height:1.45}
        .status{padding:2px 6px;border-radius:999px;border:1px solid var(--line)}
        .SENT{color:var(--warn);border-color:#5a4d1d}
        .DELIVERED{color:var(--info);border-color:#234d8a}
        .READ{color:var(--ok);border-color:#1c5a34}
        .actions{display:flex;gap:6px;margin-top:8px}
        input[type="text"]{flex:1;min-width:140px;padding:12px;border-radius:12px;border:1px solid var(--line);background:#0f1526;color:var(--fg)}
        .btn{display:inline-flex;align-items:center;gap:8px;padding:10px 12px;border-radius:12px;border:1px solid var(--line);background:#0c1220;color:var(--fg);cursor:pointer}
        .btn:hover{filter:brightness(1.06)}
        .btn.ghost{background:rgba(255,255,255,.02)}
        .btn.danger{border-color:#4a1d1d;color:#ffb4b4;background:rgba(239,68,68,.08)}
        .toolbar{display:flex;gap:10px;align-items:center;flex-wrap:wrap;margin-top:10px}
        .small{font-size:12px;color:var(--muted)}
    </style>
</head>
<body>
<div class="wrap">
    <div class="top">
        <h2 style="margin:0">실시간 채팅</h2>
        <span class="pill" id="pill-room"></span>
    </div>

    <div class="grid">
        <aside class="side card">
            <div class="legend">접속 정보</div>
            <div id="whoami" style="font-weight:700;margin-bottom:8px;"></div>
            <div class="hr"></div>
            <div class="legend">도움말</div>
            <p class="small">
                • 이 페이지를 <b>두 탭</b>으로 열고, 각각 <b>index.html</b>에서 다른 사용자로 들어오세요.<br/>
                • 내가 보낸 메시지는 <b>READ 이전</b>(= SENT/DELIVERED)까지만 수정/삭제 가능합니다.
            </p>
            <div class="hr"></div>
            <button id="btn-refresh" class="btn ghost" onclick="fetchHistory(50)">최근 내역 다시 가져오기</button>
            <a class="btn" href="/index.html" style="margin-left:8px">사용자 선택으로</a>
        </aside>

        <main class="main card">
            <div id="chat" class="chat"></div>
            <div class="hr"></div>
            <div class="toolbar">
                <input type="text" id="msg" placeholder="메시지를 입력하세요 (Enter 전송)" />
                <button id="btn-send" class="btn">전송</button>
            </div>
        </main>
    </div>
</div>

<script>
    // ===== URL 파라미터에서 고정 사용자/룸 읽기 =====
    const params = new URLSearchParams(location.search);
    const ROOM_ID = params.get('room') || 'Choi-Kim';
    const currentUser = params.get('user') || 'Choi'; // ✅ 페이지 내 변경 불가
    const DISPLAY = { Choi: '최성민', Kim: '김도영' };

    // UI 표시
    document.getElementById('pill-room').innerHTML = `room: <b>${ROOM_ID}</b>`;
    document.getElementById('whoami').textContent = `현재 사용자: ${DISPLAY[currentUser]} (${currentUser})`;

    // ===== 상태/DOM =====
    let client = null; // STOMP
    const $ = (s)=>document.querySelector(s);
    const chatEl = $('#chat');
    const messageEls = new Map(); // id -> element
    const fmt = (x)=> new Date(x).toLocaleTimeString();

    // ===== 렌더 =====
    function upsertMessage(m){
      const { id, senderKey, content, status, createdAt } = m;
      let box = messageEls.get(id);
      const mine = senderKey === currentUser;
      const alignClass = mine ? 'mine' : 'other';

      if(!box){
        box = document.createElement('div');
        box.className = `msg ${alignClass}`;
        box.dataset.id = id;
        box.innerHTML = `
          <div class="meta">
            <span class="name">${DISPLAY[senderKey] ?? senderKey}</span>
            <span class="time">${fmt(createdAt)}</span>
            <span class="status ${status}">${status}</span>
          </div>
          <div class="content"></div>
          <div class="actions"></div>
        `;
        chatEl.appendChild(box);
        messageEls.set(id, box);
      } else {
        // (혹시 재렌더가 필요할 땐) 정렬 클래스 유지
        box.className = `msg ${alignClass}`;
      }

      box.querySelector('.content').textContent = content;

      const st = box.querySelector('.status');
      st.textContent = status;
      st.className = `status ${status}`;

      const actions = box.querySelector('.actions');
      actions.innerHTML = '';
      if(mine && status !== 'READ'){
        const b1 = document.createElement('button');
        b1.className='btn ghost';
        b1.textContent='수정';
        b1.onclick=()=> onEdit(id);

        const b2 = document.createElement('button');
        b2.className='btn danger';
        b2.textContent='삭제';
        b2.onclick=()=> onDelete(id);

        actions.appendChild(b1); actions.appendChild(b2);
      }

      chatEl.scrollTop = chatEl.scrollHeight;
    }

    function removeMessage(id){
      const el = messageEls.get(id);
      if(el){ el.remove(); messageEls.delete(id); }
    }

    function renderList(list){
      chatEl.innerHTML = '';
      messageEls.clear();
      list.forEach(upsertMessage);
      chatEl.scrollTop = chatEl.scrollHeight;
    }

    // ===== REST: 히스토리 =====
    async function fetchHistory(limit=50){
      const r = await fetch(`/api/rooms/${ROOM_ID}/messages?limit=${limit}`);
      if(!r.ok){ alert('히스토리 로드 실패'); return; }
      renderList(await r.json());
    }

    // ===== STOMP =====
    function connectWS(){
    const sock = new SockJS('/ws');
    client = Stomp.over(sock);
    client.debug = null; // 로그 억제

    client.connect({}, () => {
      // 구독
      client.subscribe(`/topic/rooms/${ROOM_ID}`, (msg) => {
        const payload = JSON.parse(msg.body);
        if (payload && payload.type === 'deleted') {
          removeMessage(payload.messageId);
        } else {
          upsertMessage(payload); // 서버가 READ로 올려 방송함
        }
      });

      // ✅ 입장 이벤트: DELIVERED 생략, 바로 READ로 승격 후 그 결과만 방송
      client.send('/app/enter', {}, JSON.stringify({
        roomId: ROOM_ID,
        userKey: currentUser
      }));

      // (선택) 아주 잠깐 뒤에 히스토리 동기화
      setTimeout(() => fetchHistory(50), 120);
    }, (err) => {
      console.error('STOMP connect error', err);
      alert('WebSocket 연결 실패');
    });
  }

    function ensureActive(){
      if(!client || !client.connected){
        alert('연결되지 않았습니다.');
        return false;
      }
      return true;
    }

    // ===== 액션 =====
    function sendMessage(text){
      const content = (text ?? '').trim();
      if(!content) return;
      if(!ensureActive()) return;
      client.send('/app/send', {}, JSON.stringify({
        roomId: ROOM_ID, senderKey: currentUser, content
      }));
    }

    function onEdit(id){
      const node = messageEls.get(id);
      if(!node) return;
      const prev = node.querySelector('.content')?.textContent ?? '';
      const next = prompt('메시지 수정', prev);
      if(next === null) return;
      if(!ensureActive()) return;
      client.send('/app/edit', {}, JSON.stringify({
        messageId: id, editorKey: currentUser, newContent: next
      }));
    }

    function onDelete(id){
      if(!confirm('이 메시지를 삭제할까요? (READ 이전까지만 가능)')) return;
      if(!ensureActive()) return;
      client.send('/app/delete', {}, JSON.stringify({
        messageId: id, requesterKey: currentUser
      }));
    }

    function sendAckDelivered(){
      if(!ensureActive()) return;
      client.send('/app/ack', {}, JSON.stringify({
        roomId: ROOM_ID, receiverKey: currentUser
      }));
    }

    function sendAckReadAll(){
      if(!ensureActive()) return;
      client.send('/app/read', {}, JSON.stringify({
        roomId: ROOM_ID, readerKey: currentUser
      }));
    }

    // ===== 이벤트 =====
    window.addEventListener('DOMContentLoaded', async ()=>{
  // 초기: 히스토리 → STOMP 연결
  await fetchHistory(50);
  connectWS();

  // 전송
  document.getElementById('btn-send').addEventListener('click', ()=>{
    const i = document.getElementById('msg');
    sendMessage(i.value);
    i.value='';
    i.focus();
  });

  document.getElementById('msg').addEventListener('keydown', e=>{
    if(e.key === 'Enter'){
      sendMessage(e.target.value);
      e.target.value='';
    }
  });

  // 히스토리 갱신
  document.getElementById('btn-refresh').addEventListener('click', ()=> fetchHistory(50));

  // 포커스 복귀 시 상태 승격
  window.addEventListener('focus', ()=>{
    sendAckDelivered();
    sendAckReadAll();
  });
});

// ✅ 전역 단축키: Ctrl/Cmd + R → 히스토리 재조회 (브라우저 새로고침 방지)
window.addEventListener('keydown', (e)=>{
  if (e.key.toLowerCase() === 'r' && (e.ctrlKey || e.metaKey)) {
    e.preventDefault();
    fetchHistory(50);
  }
});

</script>
</body>
</html>

